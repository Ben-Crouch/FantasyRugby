"""
Draft management views for Fantasy Rugby API

This module handles all draft-related operations including:
- Starting drafts
- Completing drafts
- Draft status tracking
"""

from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from ..databricks_rest_client import DatabricksRestClient
from .utils import get_cached_result, set_cached_result


@api_view(['GET'])
@permission_classes([AllowAny])
def debug_database(request):
    """
    Debug endpoint to check database tables and schema
    """
    try:
        client = DatabricksRestClient()
        
        # Check if team_players table exists
        check_table_sql = "SHOW TABLES IN default LIKE 'team_players'"
        table_check = client.execute_sql(check_table_sql)
        
        # If table doesn't exist, create it
        if not table_check or 'result' not in table_check or not table_check['result'].get('data_array'):
            create_table_sql = """
            CREATE TABLE IF NOT EXISTS default.team_players (
                id BIGINT GENERATED BY DEFAULT AS IDENTITY,
                team_id BIGINT,
                player_id BIGINT,
                position STRING,
                fantasy_position STRING,
                is_starting BOOLEAN
            )
            """
            create_result = client.execute_sql(create_table_sql)
            return Response({
                'message': 'team_players table created',
                'create_result': create_result
            })
        else:
            # Check table schema
            describe_sql = "DESCRIBE default.team_players"
            describe_result = client.execute_sql(describe_sql)
            
            # Check actual data in the table
            data_sql = "SELECT * FROM default.team_players"
            data_result = client.execute_sql(data_sql)
            
            # Test the SQL query that get_team_players uses
            test_sql = """
            SELECT tp.player_id, tp.position, tp.fantasy_position, tp.is_starting, rp."Player Name", rp.Team
            FROM default.team_players tp
            LEFT JOIN default.rugby_players_25_26 rp ON tp.player_id = rp."Player ID"
            WHERE tp.team_id = 2
            ORDER BY tp.is_starting DESC, tp.position
            """
            test_result = client.execute_sql(test_sql)
            
            return Response({
                'message': 'team_players table exists',
                'table_check': table_check,
                'schema': describe_result,
                'data': data_result,
                'test_query_result': test_result
            })
            
    except Exception as e:
        return Response({
            'error': str(e),
            'traceback': str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
@permission_classes([AllowAny])
def complete_draft(request, league_id):
    """
    Complete the draft by saving all team rosters
    """
    try:
        data = request.data
        team_rosters = data.get('team_rosters', [])
        
        if not team_rosters:
            return Response({'error': 'Team rosters are required'}, status=status.HTTP_400_BAD_REQUEST)
        
        client = DatabricksRestClient()
        
        # Clear existing team players for this league
        clear_sql = f"""
        DELETE FROM default.team_players 
        WHERE team_id IN (
            SELECT id FROM default.league_teams WHERE league_id = {league_id}
        )
        """
        clear_result = client.execute_sql(clear_sql)
        
        # Insert new team rosters using batch insert for better performance
        all_insert_values = []
        
        for team_roster in team_rosters:
            team_id = team_roster.get('team_id')
            players = team_roster.get('players', [])
            
            if not team_id or not players:
                continue
            
            for player in players:
                player_id = player.get('id')
                position = player.get('position', '')
                fantasy_position = player.get('fantasy_position', '')
                is_starting = player.get('is_starting', False)
                
                if not player_id:
                    continue
                
                # Escape single quotes in string values
                position_escaped = position.replace("'", "''")
                fantasy_position_escaped = fantasy_position.replace("'", "''")
                
                all_insert_values.append(f"({team_id}, {player_id}, '{position_escaped}', '{fantasy_position_escaped}', {str(is_starting).lower()})")
        
        # Batch insert all players at once
        if all_insert_values:
            batch_insert_sql = f"""
            INSERT INTO default.team_players (team_id, player_id, position, fantasy_position, is_starting)
            VALUES {', '.join(all_insert_values)}
            """
            
            result = client.execute_sql(batch_insert_sql)
            
            if not result or 'status' not in result or result['status'].get('state') != 'SUCCEEDED':
                return Response({'error': f'Failed to save team rosters: {result}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
        # Update league draft status to COMPLETED
        update_sql = f"""
        UPDATE default.user_created_leagues 
        SET draft_status = 'COMPLETED' 
        WHERE id = {league_id}
        """
        update_result = client.execute_sql(update_sql)
        
        if not update_result or 'status' not in update_result or update_result['status'].get('state') != 'SUCCEEDED':
            return Response({'error': f'Failed to update draft status: {update_result}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
        return Response({
            'message': 'Draft completed successfully',
            'players_inserted': len(all_insert_values)
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        print(f"ERROR in complete_draft: {str(e)}")
        import traceback
        error_details = traceback.format_exc()
        print(f"ERROR traceback: {error_details}")
        return Response({
            'error': str(e),
            'traceback': error_details
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
@permission_classes([AllowAny])
def start_draft(request, league_id):
    """
    Start the draft for a league
    """
    try:
        client = DatabricksRestClient()
        
        # Update league draft status to LIVE
        sql = f"""
        UPDATE default.user_created_leagues 
        SET draft_status = 'LIVE' 
        WHERE id = {league_id}
        """
        result = client.execute_sql(sql)
        
        if not result or 'status' not in result or result['status'].get('state') != 'SUCCEEDED':
            return Response({'error': f'Failed to start draft: {result}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
        return Response({'message': 'Draft started successfully'}, status=status.HTTP_200_OK)
        
    except Exception as e:
        print(f"ERROR in start_draft: {str(e)}")
        return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['GET'])
@permission_classes([AllowAny])
def get_draft_status(request, league_id):
    """
    Get the current draft status for a league
    """
    try:
        client = DatabricksRestClient()
        
        # Check cache first
        cache_key = f'draft_status_{league_id}'
        cached_result = get_cached_result(cache_key)
        if cached_result:
            return Response(cached_result)
        
        sql = f"SELECT draft_status FROM default.user_created_leagues WHERE id = {league_id}"
        result = client.execute_sql(sql)
        
        if result and 'result' in result and result['result'].get('data_array'):
            draft_status = result['result']['data_array'][0][0]
            response_data = {'draft_status': draft_status}
            
            # Cache the result
            set_cached_result(cache_key, response_data)
            return Response(response_data)
        else:
            return Response({'draft_status': 'NOT_STARTED'})
            
    except Exception as e:
        print(f"ERROR in get_draft_status: {str(e)}")
        return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
